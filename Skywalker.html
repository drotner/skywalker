<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/meyer-reset/2.0/reset.min.css" />
    <link rel="stylesheet" href="//cdn.rawgit.com/milligram/milligram/master/dist/milligram.min.css">
    <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Roboto+Condensed:300,300i,400,400i,700,700i|Roboto+Mono:300,300i,400,400i,700,700i" />
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/prism/1.14.0/themes/prism.min.css" />
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/prism/1.14.0/plugins/line-numbers/prism-line-numbers.min.css" />
    <link rel="stylesheet" href="Skywalker.css" />
    <title>Skywalker Design Document</title>
</head>
<body>
<!-- 
***************************************************************************************************
DOCUMENT START
***************************************************************************************************
-->
<div class="md">
    # Project Skywalker
    #### Design Document v0.1 - First Draft

    Author: Rolf Lunder
</div>
<div class="pb"></div>
<div class="md">
    # Table of Contents
</div>
<div id="toc"></div>
<div class="pb"></div>
<div id="content">
<div class="md">
    # Introduction

    *Skywalker* is the code name for a new SIM architecture. As we are progressing towards Snow Sky we see that the requirements for SIM are going to change. At some time in future, most of our software is going run as services in the cloud, and for many customers, SIM might end up being the only product from us that they have installed on-premises. This has significance for how we think about SIM, and what it should do. It is no longer only about moving data from a to b on a schedule.
    
    Our cloud services will require information about the customer's internal systems and vice versa. Snow Sky will have to be able to signal events to and configure the software that is running on-premises. SIM will become more of a cloud extender than a data pipe, and it will have to be online and connected at all times.

    In order to support customer environments of varying sizes and complexity, we need a system that is both modular and flexible. We should allow the customer to run everything in a distributed fashion, and at the same time provide a solution that feels unified and is easy to manage.

    Even for customers that must run everything on-premises, we should provide the exact same experience. Whatever we build for the cloud must also be able to run internally.
</div>
<div class="pb"></div>
<div class="md">
    # Fundamental Building Blocks

    In this chapter, we are going sketch up the fundamental building blocks that will make it possible for us to build a modular and flexible system that can evolve over time. It is going to be fairly technical, and we're going to use a lot of pseudo-code to explain the concepts. In order to make everything more digestable, however, we are going accompany the code with diagrams that visualize the results. Hopefully, this will enable even those that do not read code fluently to tag along.

    Before we start, I would like to warn you that we will start our journey at quite a low level. There is a reason for that. I want to make sure that we establish a solid understanding of the fundamentals before we start looking at the broader picture. I've taken a bottom-up approach and tried to design a generic framework that can serve as a foundation for anything that we want to build now and in the future.
</div>
<div class="md">
    ## Nodes
    At the heart of the new SIM design is the *Node* class. This class provides everything we need to compose complex and distributed systems. It is the glue in the architecture, and most of the code running in SIM will probably share an intimate relashionship with it.

    What better way is there to explain what a node is than to show how it actually works? 

    Let's start by creating a node:
</div>
<pre><code class="lang-csharp line-numbers">var a = new Node("a");</code></pre>
<div class="frame">
    <div class="dot">
        a
    </div>
</div>
<div class="md">
    OK, so now we have a single node named *a*. Let's create a second one named *b*:
</div>
<pre><code class="lang-csharp line-numbers">var b = new Node("b");
</code></pre>
<div class="frame">
    <div class="dot">
        a->b[color=transparent]
    </div>
</div>
<div class="md">
    At this point, these nodes are islands. They do not know of each other, and there is no way for them to communicate. Let's fix that!
</div>
<div class="md">
    Nodes can connect to each other and form networks. First, we make *a* listen and accept connections on TCP/IP port 4242:
</div>
<pre><code class="lang-csharp line-numbers">a.Listen("tcp://localhost:4242");</code></pre>
<div class="md">
    Then, connect *b* to *a*:
</div>
<pre><code class="lang-csharp line-numbers">b.Connect("tcp://localhost:4242");</code></pre>
<div class="frame">
<div class="dot">
        a->b[label="tcp:4242#0"]
    </div>
</div>
<div class="md">
    Good! *b* is now connected to *a* over TCP/IP, and we can see the beginnings of a graph structure. It is time to introduce our next building block.
</div>
<div class="md">
    ## Edges

    We call the connections between nodes, *edges*. Observe that the parent node, here *a*, will assign each edge a unique *handle*. In this case *"tcp:4242#0"*, which tells us that this is the first TCP/IP connection on port 4242. If another node connects to *a*, the resulting edge would get the handle *"tcp:4242#1"*, the next edge *"tcp:4242#2"*, and so on. This will become important later on.

    We are now running all the nodes in the same process, but as you probably have already infered, nodes can run on different machines and connect to each other over TCP/IP. For simplicity's sake though, we'll continue running the nodes in this example in the same process, but rest assured that there is nothing keeping us from distributing nodes across different machines in our network.

    So far we have created two nodes and given them names. Names are good for human readability, but that that is also all they are ever used for. In fact, there is nothing stopping us from creating multiple nodes with the same name. It is not a good idea to do so, but the system makes no effort to prohibit such a scenario. Thus, we need a more precise way to address a particular node. For that, we use the node's *Id*:
</div>
<pre><code class="lang-csharp line-numbers">a.Id.Dump();
b.Id.Dump();
</code></pre>
<pre><code class="lang-text">a3a7e8c2-053d-4a95-b2f1-4fcf2bd06a25
c4ef0640-5171-44a7-95b6-db130b3dcb90
</code></pre>
<div class="md">
    As you can see, we use GUIDs for node Ids. When we created the above nodes we did not specify their Ids, so they simply generated random ones. Generally, in production we would like a node's Id to be static and survive system restarts and crashes, so we would probably store it in some kind of durable configuration and pass it in during startup.

    OK, let's add some more nodes and connect them to get a more interesting topology to work with:
</div>
<pre><code class="lang-csharp line-numbers">// Create node c with a specific Id:
var c = new Node("c", new Guid("38309a8f-25aa-499b-9c67-2bcbf2ee55c3"));
var d = new Node("d");

c.Connect("tcp://localhost:4242");
d.Connect("tcp://localhost:4242");

c.Listen("inproc://c");

var e = new Node("e");
var f = new Node("f");

e.Connect("inproc://c");
f.Connect("inproc://c");
</code></pre>
<div class="frame">
    <div class="dot">
        a->b[label="tcp:4242#0"]
        a->c[label="tcp:4242#1"]
        a->d[label="tcp:4242#2"]
        c->e[label="inproc#0"]
        c->f[label="inproc#1"]
    </div>
</div>
<div class="md">
    Nodes can have 0-1 parent, and 0-n children. Also, there can be no cycles in the graph, so we're constrained to form tree topologies. Note that to save space, the graph illustrations in this document is laid out from left to right, but we're still talking about going up and down the branches in the tree. *Just remember that left is up, and right is down, and that branches go from top to bottom.*

    Observe that node *c* is listening on the *inproc* transport. This is an in-process transport that can be used to connect nodes that are running in the same host process. The motivation for having such a transport is to avoid unnecessary round-trips to the loopback interface. Other than that, an *inproc* edge behaves exactly like a *tcp* edge, and nodes should not care about which kind of transport they are connected over.

    Edges will actively try to keep the connection open and re-connect if it goes down for some reason. Edges will also buffer data, first to memory, and then to disk, until the connection has been re-established. 
</div>
<div class="md">
    ## Messages

    Nodes communicate by sending messages to each other. A message looks something like this:
</div>
<pre><code class="lang-csharp line-numbers">public struct Message
{
    public Guid SenderId;   // The Id of the node that sent the message
    public Guid ReceiverId; // The Id of the node that should receive the message
    public Frame[] Frames;  // The data frames which constitute the content of the message
}

public struct Frame
{
    public byte[] Buffer;
}    
</code></pre>
<div class="md">
    As you can see, a message has a sender and a receiver, and an array of frames. A *Frame* is simply a wrapper for a byte buffer, and we can use frames to send any kind of data that we like. For frames, the following rules apply:
    - Frame[0] is system reserved. More on that shortly...
    - Frame[1-n] are free for us to use for whatever we want to send.

    The reason we wrap the frame buffers in a struct is that it makes it easier to provide utility methods to construct and deconstruct data frames:
</div>
<pre><code class="lang-csharp line-numbers">// Construct some frames...
var utf8Frame = Frame.From("Hello, this is some text!"); // Default encoding is UTF-8
var asciiFrame = Frame.From("Hello, this is ASCII!", Encoding.ASCII);
var jsonFrame = Frame.Json(new { Message = "Hello, this is a JSON object!" }, Encoding.UTF8);

// Deconstruction
var utf8Text = utf8Frame.AsString(); // Default encoding is UTF-8
var asciiText = asciiFrame.AsString(Encoding.ASCII);
var obj = jsonFrame.DeserializeJson(Encoding.UTF8);
</code></pre>
<div class="md">
    Et cetera, you get the idea...
</div>
<div class="md">
    ### Endpoints and Protocols
    OK, so before we start sending messages we need to understand *endpoints* and *protocols*. The fact is that nodes won't accept just any random messages that you throw at them. For a node to be ready to receive anything, it needs to open an endpoint and start listening for incoming messages on it. An endpoint is very much like a local URI. For instance, a node can open the endpoint "sandbox/chat/".
    
    Right, now we can address that particular endpoint on that particular node. This is exactly what Frame[0] is reserved for. When we construct the message, we specify which endpoint we want to reach as an ASCII encoded string in this frame. Our message now looks something like this:
</div>
<div class="frame">
    <table class="prop">
        <tr><th>SenderId</th><td class="monospace">{senderId}</td></tr>
        <tr><th>ReceiverId</th><td class="monospace">{receiverId}</td></tr>
        <tr><th>Frame[0]</th><td>"sandbox/chat/"</td></tr>
    </table>
</div>
<div class="md">
    Nice, so now we're ready to send the message? No, not quite yet! If we were to send this message, the node would know which endpoint it should go to, but the endpoint wouldn't have any idea how to interpret it. For that, we have *protocols*!

    When a node opens an endpoint it also has to specify one or more protocols that the endpoint supports. OK then, so what exactly is a protocol? Well, first of all, a protocol has a name and a version. We can specify a protocol using a string in the following format:

        {name}/{version}

    For example, if there is a protocol called "app.chat", and the endpoint supports version 1.0 of that, we would use the following string:

        app.chat/v1.0

    There's of course more to a protocol than its name and version. When a developer designs a protocol, there will be assumptions on what kinds of messages are acceptable, how messages look like, the order in which they can be exchanged, and so on. This is implemented in the code that actually runs behind the endpoint, and we'll have a look at an example of that later on.

    Good. Now the node has opened an endpoint and specified that it supports the *app.chat/v1.0* protocol. We can amend our message and specify which protocol we want to speak *at* the given endpoint:
</div>
<div class="frame">
    <table class="prop">
        <tr><th>SenderId</th><td class="monospace">{senderId}</td></tr>
        <tr><th>ReceiverId</th><td class="monospace">{receiverId}</td></tr>
        <tr><th>Frame[0]</th><td>"app.chat/v1.0@sandbox/chat/"</td></tr>
    </table>
</div>
<div class="md">
    OK, so now we're telling the receiving node that we want to talk app.chat/v1.0 **at** the endpoint *sandbox/chat*.

    Before we move along, here are some constraints that apply to endpoints and protocols:
    - An endpoint is a sequence of one or more path segments separated by a '/' character.
    - An endpoint always ends with a trailing slash. If you forget to specify a trailing slash, one will be added for you by the system.
    - Valid characters for endpoints are alphanumeric characters + '/' and '-'.
    - The *sys/* endpoint is reserved by the system, and you cannot open it or any other endpoint under it.
    - A protocol name is a sequence of one or more path segments separated by a '.' character.
    - After the protocol name comes a trailing '/' character and then the version.
    - The protocol version is in the format "v{major}.{minor}".
    - There are a number of required "sys.*" protocols that live behind the *sys/* endpoint. These are already implemented by the *Node* class.

    Awesome, we're finally ready to send the message!
</div>
<div class="md">
    ### Sending Messages
    To send a message, we can use one of the node's *Send(...)* methods. Let's send a simple message from *c* to *a*:
</div>
<pre><code class="lang-csharp line-numbers">c.Send("a3a7e8c2-053d-4a95-b2f1-4fcf2bd06a25", "app.chat/v1.0@sandbox/chat/", Frame.From("Hello, a!"));
</code></pre>
<div class="md">
    The first parameter is the *Id* of the intended receiver, in this case node *a*. 

    The second parameter is the required protocol/endpoint definition that will go into Frame[0] of the message. Here we have specified that we want to talk version 1.0 of our imaginary protocol *app.chat* at the endpoint *sandbox/chat/*.

    Lastly, we have a params array of additional "user frames" to send with the message. In this example, we are sending a single frame of text. It is the protocol that dictates what frames to 

    The following illustration depicts the message exchange caused by the method call. The sender node has a red outline, while receiving nodes have been "triggered" and are now red. Red arrows show the flow of the message. The message details can be found on the right side of the illustration. This is the convention that we are going to use throughout this document to show message flows.
</div>
<div class="frame">
    <div class="horiz">
        <div class="dot">
            a[fillcolor=firebrick2]
            b
            c[color=firebrick2]
            d
            e
            f
            a->b[label="tcp:4242#0"]
            a->c[label="tcp:4242#1" style=solid color=firebrick2 dir=back]
            a->d[label="tcp:4242#2"]
            c->e[label="inproc#0"]
            c->f[label="inproc#1"]
        </div>
        <div class="vr"></div>
        <table class="prop">
            <tr><th>SenderId</th><td class="monospace">38309a8f-25aa-499b-9c67-2bcbf2ee55c3</td></tr>
            <tr><th>ReceiverId</th><td class="monospace">a3a7e8c2-053d-4a95-b2f1-4fcf2bd06a25</td></tr>
            <tr><th>Frame[0]</th><td>"app.chat/v1.0@sandbox/chat"</td></tr>
            <tr><th>Frame[1]</th><td>"Hello, a!"</td></tr>
        </table>
    </div>
</div>
<div class="md">
    Observe that we can find the protocol/endpoint definition in *Frame[0]*. *Frame[1]* is the first *user frame*, and it contains the text that we want to send.
    
    OK, so how does *c* know where to send the message? Well, actually it doesn't!
    
    A node doesn't know anything about the hierarchy above itself. Coincidentally, this example works because when a node wants to send a message to a receiver that it doesn't know the location of, it simply passes the message to its parent. In this case the intended receiver actually *is* the parent, so... problem solved!

    Unfortunately, communicating only with your parents and grandparents gets old really fast. We need to find a way to let the nodes send messages to receivers that are not above in the same branch. That would require some kind of routing, wouldn't it? Yes, it would. So, how would that work?

</div>
<div class="md">
    ### Routing
    Routing is the process in which the nodes in the graph select a path for a message, so that it can reach its intended receiver. Well, actually, we should say "receiver**s**", because  some messages will actually be consumed by multiple nodes. This is the simplest kind of routing, and we'll have a look at that first.

    #### Relative Receivers
    There are a few hard-coded receiver ids that can be used to address nodes in relative positions to the sender node.
</div>
<pre><code class="lang-csharp line-numbers">static class Receivers
{
    // Addresses nodes that lie above the node in the same brach
    public static readonly Guid Ancestors = new Guid("00000000-0000-0000-0000-000000000000");

    // Addresses all nodes in the graph (including itself)
    public static readonly Guid Everyone = new Guid("0f0f0f0f-0f0f-0f0f-0f0f-0f0f0f0f0f0f");

    // Addresses nodes that lie below the sender
    public static readonly Guid Descendants = new Guid("ffffffff-ffff-ffff-ffff-ffffffffffff");
}
</code></pre>
<div class="md">
    Whenever a node receives a message, it will look at the *ReceiverId* and execute the following logic:
    - If *ReceiverId* is equal to the node's *Id*, it will consume the message and **not** forward it to anyone else.
    - If *ReceiverId* is equal to *Receivers.Ancestors*, it will consume the message and then forward it to its parent node.
    - If *ReceiverId* is equal to *Receivers.Everyone*, it will consume the message and then forward it to both its parent and all children nodes.
    - If *ReceiverId* is equal to *Receivers.Descendants*, it will consume the message and then forward it to all its children nodes. 

    Let's have a look at some examples to illustrate this behavior.
</div>
<div class="md">
    Example 1: Sending a message to all ancestor nodes:
</div>
<pre><code class="lang-csharp line-numbers">f.Send(Receivers.Ancestors, "app.chat/v1.0@sandbox/chat/", Frame.From("Hello, ancestors!"));
</code></pre>
<div class="frame">
    <div class="horiz">
        <div class="dot">
            a[fillcolor=firebrick2]
            b
            c[fillcolor=firebrick2]
            d
            e
            f[color=firebrick2]
            a->{b d}
            c->e
            edge[dir=back style=solid color=firebrick2]
            a->c
            c->f
        </div>
        <div class="vr"></div>
        <table class="prop">
            <tr><th>SenderId</th><td class="monospace">92ff112d-485d-4c3c-a8c1-0ca328c5882d</td></tr>
            <tr><th>ReceiverId</th><td class="monospace">00000000-0000-0000-0000-000000000000</td></tr>
            <tr><th>Frame[0]</th><td>"app.chat/v1.0@sandbox/chat/"</td></tr>
            <tr><th>Frame[1]</th><td>"Hello, ancestors!"</td></tr>
        </table>            
    </div>
</div>
<div class="md">
    Example 2: Sending a message to everyone (broadcasting):
</div>
<pre><code class="lang-csharp line-numbers">d.Send(Receivers.Everyone, "app.chat/v1.0@sandbox/chat/", Frame.From("Hello, everyone!"));
</code></pre>
<div class="frame">
    <div class="horiz">
        <div class="dot">
            a[fillcolor=firebrick2]
            b[fillcolor=firebrick2]
            c[fillcolor=firebrick2]
            d[color=firebrick2]
            e[fillcolor=firebrick2]
            f[fillcolor=firebrick2]
            a->d[dir=back style=solid color=firebrick2]
            edge[dir=forward style=solid color=firebrick2]
            a->b
            a->c
            c->e
            c->f
        </div>
        <div class="vr"></div>
        <table class="prop">
            <tr><th>SenderId</th><td class="monospace">02220e33-6e45-4b78-933e-fa7a8bdaf42a</td></tr>
            <tr><th>ReceiverId</th><td class="monospace">0f0f0f0f-0f0f-0f0f-0f0f-0f0f0f0f0f0f</td></tr>
            <tr><th>Frame[0]</th><td>"app.chat/v1.0@sandbox/chat/"</td></tr>
            <tr><th>Frame[1]</th><td>"Hello, everyone!"</td></tr>
        </table>            
    </div>
</div>
<div class="md">
    Example 3: Sending a message to all child nodes:
</div>
<pre><code class="lang-csharp line-numbers">c.Send(Receivers.Descendants, "app.chat/v1.0@sandbox/chat/", Frame.From("Hello, children!"));
</code></pre>
<div class="frame">
    <div class="horiz">
        <div class="dot">
            a
            b
            c[color=firebrick2]
            d
            e[fillcolor=firebrick2]
            f[fillcolor=firebrick2]
            a->{b d}
            c->e[dir=forward style=solid color=firebrick2]
            a->c
            c->f[dir=forward style=solid color=firebrick2]
        </div>
        <div class="vr"></div>
        <table class="prop">
            <tr><th>SenderId</th><td class="monospace">c4ef0640-5171-44a7-95b6-db130b3dcb90</td></tr>
            <tr><th>ReceiverId</th><td class="monospace">ffffffff-ffff-ffff-ffff-ffffffffffff</td></tr>
            <tr><th>Frame[0]</th><td>"app.chat/v1.0@sandbox/chat/"</td></tr>
            <tr><th>Frame[1]</th><td>"Hello, children!"</td></tr>
        </table>            
    </div>
</div>
<div class="md">
    You can see that routing these kinds of messages does not require nodes to have much knowledge of the graph around it. But what if we want to send a message that is on a completely different branch?
</div>
<div class="md">
    #### Specific Receivers
    It should be quite obvious that routing a message to an arbitrary node often requires the intermediate nodes to have some understanding of how the graph is connected. How can we bring that knowledge to them?

    Let's have a look at what happens when a node connects to another. Here *e* connects to *c*:
</div>
<pre><code class="lang-csharp line-numbers">e.Connect("inproc://c");</code></pre>
<div class="md">
    *e* immediately sends a special message called a *beacon* up the branch to notify all ancestor nodes that it exists and has been connected.
</div>
<div class="frame">
    <div class="horiz">
        <div class="dot">
            a[fillcolor=firebrick2]
            b
            c[fillcolor=firebrick2]
            d
            e[color=firebrick2]
            f
            a->b[label="tcp:4242#0"]
            a->c[label="tcp:4242#1" style=solid color=firebrick2 dir=back]
            a->d[label="tcp:4242#2"]
            c->e[label="inproc#0" style=solid color=firebrick2 dir=back]
            c->f[label="inproc#1"]
        </div>
        <div class="vr"></div>
        <table class="prop">
            <tr><th>SenderId</th><td class="monospace">3883b2ad-b7ce-41ae-b3c4-bfe2ea57d50c</td></tr>
            <tr><th>ReceiverId</th><td class="monospace">00000000-0000-0000-0000-000000000000</td></tr>
            <tr><th>Frame[0]</th><td>"sys.dir/v1.0@sys/"</td></tr>
            <tr><th>Frame[1]</th><td>"beacon"</td></tr>
            <tr><th>Frame[1]</th><td>Id=3883b2ad-b7ce-41ae-b3c4-bfe2ea57d50c<br />
Name=c<br />
PublicKey=&lt;RSAKeyValue&gt;&lt;Modulus&gt;uw+knpRKjmLpcimIrN5..."
            </td></tr>
        </table>
    </div>
</div>
<div class="md">
    The "beacon" message is part of the *sys.dir* protocol (system directory). This protocol is one of several system protocols that all nodes are required to support, all of which start with "sys.", and all of which live at the reserved "sys/" endpoint. The *Node* class already implements all of them, so this is nothing we have to worry about.

    Looking at the message details we can see that *ReceiverId* == *Receivers.Ancestors*, so this message should float up the branch and eventually reach the root node. Along the way, all ancestor nodes should also consume the message. We can see from the illustration that this is exactly the case.

    The beacon message also contains information about the node's name and public key (to be used for encrypted communication). The *sys.dir* module that is running in all ancestor nodes will consume this information and keep it a routing table for look-up later.
    
    As soon as the connecting node has sent its own beacon message, it will loop through its own routing table and send beacon messages for all its descendants as well. This way, the *sys.dir* module will build a complete picture of what nodes are beneath it.
    
    The routing table is a kind of dictionary that looks something like this:
</div>
<pre><code class="lang-json">{
    ...,
    "3883b2ad-b7ce-41ae-b3c4-bfe2ea57d50c": {
        "edge": "tcp:4242#1",
        "name": "c",
        "publicKey": "&lt;RSAKeyValue&gt;&lt;Modulus&gt;uw+knpRKjmLpcimIrN5..."
    },
    ...
}</code></pre>
<div class="md">
    This shows part node *a*'s routing table. We can see that we have an entry for node *c*, and that we now know which edge it is connected over. Whenever node *a* gets a message that 
    should be sent to node *c*, it knows which edge to forward the message to.

    Let's send a message from *d* to *e*:
</div>
<pre><code class="lang-csharp line-numbers">d.Send("3883b2ad-b7ce-41ae-b3c4-bfe2ea57d50c", "app.chat/v1.0@sandbox/chat/", Frame.From("Hello, e!"));
</code></pre>
<div class="frame">
    <div class="horiz">
        <div class="dot">
            a
            b
            c
            d[color=firebrick2]
            e[fillcolor=firebrick2]
            f
            a->b[label="tcp:4242#1"]
            a->d[dir=back style=solid color=firebrick2 label="tcp:4242#1"]
            c->e[dir=forward style=solid color=firebrick2 label="inproc#0"]
            a->c[dir=forward style=solid color=firebrick2 label="tcp:4242#2"]
            c->f[label="inproc#1"]
        </div>
        <div class="vr"></div>
        <table class="prop">
            <tr><th>SenderId</th><td class="monospace">02220e33-6e45-4b78-933e-fa7a8bdaf42a</td></tr>
            <tr><th>ReceiverId</th><td class="monospace">3883b2ad-b7ce-41ae-b3c4-bfe2ea57d50c</td></tr>
            <tr><th>Frame[0]</th><td>"app.chat/v1.0@sandbox/chat/"</td></tr>
            <tr><th>Frame[1]</th><td>"Hello, e!"</td></tr>
        </table>            
    </div>
</div>
<div class="md">
    Right, here we can observe the following flow:
    1. *d*, which does not know where *e* is located, sent the message to *a* because it is *d*'s parent. 
    2. The message was not ment for *a*, so it looked in its routing table, found an entry, and then forwarded the message down the correct edge to *c*. 
    3. *c* in turn followed the same procedure as *a*, and then forwarded it to *e*.
    4. *e* figured out that it was the receiver and consumed the message.

    Alright, routing now works, but what did *e* actually do with the message? Well, the message was handled by the "app.chat" module, of course!
</div>
<div class="md">
    ## Modules

    As we discussed earlier, protocols have a name, a version, and an implementation. We call the code that implements the protocol a *module*.
    
    Let's have a look at how an implementation of the *app.chat* protocol could look like. This sample module simply receives a chat message and dumps the text to out to the console. It's not a very useful protocol, but it will suffice as demonstration.
</div>
<pre><code class="lang-csharp">var cts = new CancellationTokenSource();

// Create an async task that executes the module
var appChat = Task.Run(() =>
{
    // Register an endpoint on the node and announce that we support the "app.chat/v1.0" protocol
    if (e.TryRegisterEndpoint("sandbox/chat", "app.chat/v1.0", out var endpoint, out var error))
    {
        // Iterate through all messages that we receieve on the endpoint.
        // If the node shuts down, or cancellation is requested on cts, the
        // enumerable will "yield break;" and the loop consequently ends...
        foreach (var msg in endpoint.Receive(cts.Token))
        {
            // Yay, we got a message! Frame[1] should hold our greeting, read it as a string
            var greeting = msg.Frame[1].AsString();
    
            // Dump the message to console
            greeting.Dump();
        }
    }
    else
    {
        // Failed to register endpoint.
        error.Dump();
    }
}, cts.Token);

// Wait until the module quits...
appChat.Wait();
</code></pre>
<pre><code class="lang-text">Hello, e!</code></pre>
<div class="md">
    OK, so that's working.
    
    Of course, we could make this module much more reusable by wrapping it in a class and take the node in as a constructor parameter, but that is entirely up to us. We could just as well implement the module in a static method, or use some other technique. The point here is that the framework doesn't actually have a concept for modules. A module is simply some piece of code running against a node, utilizing the its features to communicate with modules in other nodes to accomplish some goal. We are free to compose our modules as we wish, and that is a good thing. We want to keep the framework lean and mean, and put as few assumptions in there as we can possibly get away with.
</div>
<div class="pb"></div>
<div class="md">
    # System Protocols
    We should already have a solid basis on which we can build almost anything. With a little ingenuity, we should be able to device protocols for any conceivable problem that could come our way in the future. There are, however, some loose ends to tie up from a framework perspective.

    For instance, there are problems that almost any code that is running in SIM will have to solve. It makes sense that we do not have to keep re-inventing the wheel every time these problems surface. That is what we have system protocols for.

    Whenever there is a concern that is shared among several modules, we should generalize the problem into a system protocol and implement the solution in a system module. Since system modules follow the node, the functionality will be available wherever someone is using one.

    In this chapter we'll discuss a few system protocols that it seems obvious that we need at this time. We might discover more later, some might prove not to be that useful anyway, but it should be a starting point for discussion.
</div>
<div class="md">
    ## System Directory (sys.dir)
    We already had a passing look at the *sys.dir* protocol earlier in this document when we looked at how routing works.

    ### Dynamic Discovery

    The *sys.dir* protocol allows us to do dynamic discovery. By *discovery* we mean the act of probing the graph for nodes that implement protocols that we are interested in. For instance, if *b* wants to know all nodes that implement app.chat, we could run the following query:
</div>
<pre><code class="lang-csharp line-numbers">// Get a temporary endpoint to receive replies on
var replyEndpoint = d.GetTempEndpoint();

// Broadcast the query to all nodes
d.Send(Receivers.Everyone, "sys.dir/v1.0@sys/",
    Frame.From("query"),
    Frame.From("protocol=app.chat/v1.0"),
    replyEndpoint);

// We'll collect the ids of all responding nodes in this list
var nodeIds = new List<Guid>();

// Receive all replies that come back within the next two seconds
foreach (var msg in replyEndpoint.Receive(TimeSpan.FromSeconds(2)))
{
    if (msg.Frame[1].AsString() == "match")
    {
        // Add the sender to the list
        nodeIds.Add(msg.SenderId);
    }
}

// nodeIds now contains the ids of all nodes that claim to implement the app.chat/v1.0 protocol.
</code></pre>
<div class="md">
    Ouch, that seems a little bit involved. Luckily, the node's built-in *SystemDirectory* module will do all that work for us, since it already implements the complete *sys.dir* protocol:
</div>
<pre><code class="lang-csharp line-numbers">var queryResult = await d.SystemDirectory.QueryAsync("protocol=app.chat/v1.0", TimeSpan.FromSeconds(2)));
</code></pre>
<div class="frame">
    <div class="caption">1) d broadcasts the query</div>
    <div class="horiz">
        <div class="dot">
            a[fillcolor=firebrick2]
            b[fillcolor=firebrick2]
            c[fillcolor=firebrick2]
            d[color=firebrick2]
            e[fillcolor=firebrick2]
            f[fillcolor=firebrick2]
            a->d[dir=back style=solid color=firebrick2]
            edge[dir=forward style=solid color=firebrick2]
            a->b
            a->c
            c->e
            c->f
        </div>
        <div class="vr"></div>
        <table class="prop">
            <tr><th>SenderId</th><td class="monospace">02220e33-6e45-4b78-933e-fa7a8bdaf42a</td></tr>
            <tr><th>ReceiverId</th><td class="monospace">0f0f0f0f-0f0f-0f0f-0f0f-0f0f0f0f0f0f</td></tr>
            <tr><th>Frame[0]</th><td>"sys.dir/v1.0@sys/"</td></tr>
            <tr><th>Frame[1]</th><td>"query"</td></tr>
            <tr><th>Frame[2]</th><td>"protocol=app.chat/v1.0"</td></tr>
            <tr><th>Frame[3]</th><td>"sys/tmp/ae7216ljs/"</td></tr>
        </table>            
    </div>
</div>
<div class="frame">
        <div class="caption">2) e and f send replies</div>
    <div class="horiz">
        <div class="dot">
            a
            b
            c
            d[fillcolor=firebrick2]
            e[color=firebrick2]
            f[color=firebrick2]
            a->d[dir=forward style=solid color=firebrick2]
            a->b
            edge[dir=back style=solid color=firebrick2]
            a->c
            c->e
            c->f
        </div>
        <div class="vr"></div>
        <table class="prop">
            <tr><th>SenderId</th><td class="monospace">{senderId}</td></tr>
            <tr><th>ReceiverId</th><td class="monospace">02220e33-6e45-4b78-933e-fa7a8bdaf42a</td></tr>
            <tr><th>Frame[0]</th><td>"sys.dir/v1.0@sys/tmp/ae7216ljs/"</td></tr>
            <tr><th>Frame[1]</th><td>"match"</td></tr>
            <tr><th>Frame[2]</th><td>"app.chat/v1.0@sandbox/chat/"</td></tr>
        </table>            
    </div>
</div>
<div class="md">
    In this case, *e* and *f* implements *app.chat/v1.0* at the *sandbox/chat* endpoint, and reply with a positive match.
</div>
<div class="md">
    ## System Configuration (sys.cfg)
    The *sys.cfg* protocol will provide mechanisms that will allow the modules that are running on a node to be remotely configured. Through it, a node will provide metadata about the different configuration settings that can be modified, and the validation rules that apply, so that a UI somewhere can render forms and present them to a user.

    I have not given very much thought to this part yet. It is undoubtedly solvable. The DevOps team has done similar things with dynamic configuration pages in Snow Installer, and we would either re-use some of their code or create something akin to that.

    TODO: Describe *sys.cfg* protocol...
</div>
<div class="md">
    ## System Host (sys.host)
    The *sys.host* protocol will allow a node to serve as a host for *connectors*. It will be possible to push a connector down to nodes that implement this protocol and install it. The node will host the connector in its own process, but it will run it in a separate app domain. A connector is actually a node in itself, and it will connect to its host node through an inproc:// transport. More on connectors shortly...

    TODO: Describe *sys.host* protocol...
</div>
<div class="pb"></div>
<div class="md">
    # Security
    All nodes have a private and a public key (RSA). A node can obtain another node's public key using the *sys.dir* protocol. The key can either be found in the node's own routing table (if the other node is a descendant), or we can ask the node's ancestors for help. Both nodes will share a common ancestor that has the details in its routing table. 

    ## Proof-of-Origin
    The sender will calculate a hash of the message contents and encrypt it with its private key. The receiver can calculate its own hash from the message content, use the sender's public key to decrypt the senders's hash, and then compare the two hashes to prove both the origin of the message and that its content has not been tampered with.

    ## Encryption
    For messages that are sent between specific nodes, there are often times no reason that intermediate nodes should be able to read the message content. They only need to read the routing information to forward the message in the right direction. Two nodes can negotiate a secure channel using a mechanism that is similar to that of the SSL/TLS handshake, albeit a little simplified. In this scenario, we consider the node that starts the conversation the client, and the other node the server:
    1. The client obtains the server's public key.
    2. The client generates a temporary endpoint (client endpoint) that will be used to receive replies from the server.
    3. The client generates a secret (for symmetric encryption) and encrypts it and the client endpoint using the server's public key.
    4. The client sends the encrypted secret and client endpoint to the server.
    5. The server decrypts the secret and client endpoint.
    6. The server generates a temporary endpoint (server endpoint) that will be used for further communication.
    7. The server encrypts the server endpoint and sends it back to the client.
    8. The client decrypts the server endpoint.
    9. Further communication between the client and server endpoints can now be symmetrically encrypted using the shared secret.

    If we want, we can add steps at the beginning to negotiate between different supported ciphers as well.

    ## Authentication and Authorization

    The topmost node in the network can serve as an authority and issue JSON Web Tokens to connecting nodes. When a node connects to the network, it will first enter a state where it can only send a limited set of messages up its own branch to authenticate itself against some user store. 
</div>
<div class="frame">
    <div class="caption">f sends an authentication message</div>
    <div class="horiz">
        <div class="dot">
            a[fillcolor=firebrick2]
            b
            c[fillcolor=firebrick2]
            d
            e
            f[color=firebrick2]
            a->d
            a->b
            a->c[style=solid color=firebrick2 dir=back]
            c->e
            c->f[style=solid color=firebrick2 dir=back]
        </div>
        <div class="vr"></div>
        <table class="prop">
            <tr><th>SenderId</th><td class="monospace">92ff112d-485d-4c3c-a8c1-0ca328c5882d</td></tr>
            <tr><th>ReceiverId</th><td class="monospace">00000000-0000-0000-0000-000000000000</td></tr>
            <tr><th>Frame[0]</th><td>"sys.dir/v1.0@sys/"</td></tr>
            <tr><th>Frame[1]</th><td>"authenticate"</td></tr>
            <tr><th>Frame[2]</th><td>"{username}:{password}"</td></tr>
            <tr><th>Frame[2]</th><td>"sys.dir/v1.0@sys/tmp/jheus8ek"</td></tr>
        </table>            
    </div>
</div>
<div class="md">
    The topmost node will reply with a token:
</div>
<div class="frame">
    <div class="caption">a replies with a token</div>
    <div class="horiz">
        <div class="dot">
            a[color=firebrick2]
            b
            c
            d
            e
            f[fillcolor=firebrick2]
            a->d
            a->b
            a->c[style=solid color=firebrick2 dir=forward]
            c->e
            c->f[style=solid color=firebrick2 dir=forward]
        </div>
        <div class="vr"></div>
        <table class="prop">
            <tr><th>SenderId</th><td class="monospace">a3a7e8c2-053d-4a95-b2f1-4fcf2bd06a25</td></tr>
            <tr><th>ReceiverId</th><td class="monospace">92ff112d-485d-4c3c-a8c1-0ca328c5882d</td></tr>
            <tr><th>Frame[0]</th><td>"sys.dir/v1.0@sys/"</td></tr>
            <tr><th>Frame[1]</th><td>"authenticated"</td></tr>
            <tr><th>Frame[2]</th><td>"Bearer eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYmYiOjE1MjU4..."</td></tr>
        </table>            
    </div>
</div>
<div class="md">
    Of course, this is a simplified flow. When we implement this for real, *a* and *f* will first have to negotiate a secure channel to use for exchanging the credentials and token. I have omitted that part here for the sake of clarity.
    
    We can add security tokens into Frame[0] in our messages much like we would do for HTTP request headers:

        app.chat/v1.0@sandbox/chat/
        Authorization: Bearer eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYmYiOjE1MjU4... 

    Nodes can then secure their endpoints by requiring certain claims to be present in the incoming message's bearer token.
</div>
<pre><code class="lang-csharp line-numbers">// Register and secure an endpoint
if (e.TryRegisterEndpoint("sandbox/chat", "app.chat/v1.0", out var endpoint, out var error))
{
    endpoint.Authorize("smalltalker");
}
</code></pre>
<div class="pb"></div>
<div class="md">
    # Deployable Bits
    ## SIM Service
    We'll package a node and all its system modules in a windows service. We enable the *sys.host* module on the node, so that it is able to host connectors.

    This will be what customers will install internally on their servers, and they can connect the services together in a way that makes sense for their environment.

    ## Connectors
    A connector is simply a node and a custom module that does something interesting, wrapped in a package that can be deployed to and hosted by a SIM Service.

    Generally, we will write our connectors in a much more modular way that we do today. We will split the connectors into multiple parts, and the parts will find each other through a combination of dynamic discovery and configuration, and then talk to each other using a common protocol.
</div>
<div class="pb"></div>
<div class="md">
    # Skywalker and Snow Sky
    There really isn't that much to say about how this relates to Snow Sky, because the code doesn't care where it is running. We can simply spin up nodes as worker roles in Azure. Those nodes will connect with services in Snow Sky through connectors, and on-premises nodes will connect the nodes in the cloud. 

    Here's an example of what it *could* look like.
</div>
<div class="frame">
    <div class="caption">Snow Sky Configuration</div>
    <div class="dot">
        newrank=true
        subgraph cluster_skyback {
            label="SIM Sky Backend"
            a
            node[shape=circle]
            a1 a2 a3
            a->{a1 a2 a3}
        }

        subgraph cluster_skyfront {
            label="SIM Sky Frontend"
            b
        }
    
        subgraph cluster_onprem {
            label="On-premises"
            c d e
            c->d
            c->e
            d->{f g h}
            e->{i j}
            k->{l m}
        }
    
        a->b
        b->c
        b->k

        subgraph cluster_skysvc {
            label="Snow Sky Services"
            node[shape=component]
            sky1
            sky2
            sky3
        }

        a1->sky1
        a2->sky2
        a3->sky3

        {rank=same; a b}
        {rank=same; sky1 c k}
    </div>
</div>
</div>
<!-- 
***************************************************************************************************
DOCUMENT END
***************************************************************************************************
-->
<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/showdown/1.8.6/showdown.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/viz.js/1.8.1/viz.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/prism/1.14.0/prism.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/prism/1.14.0/components/prism-csharp.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/prism/1.14.0/components/prism-json.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/prism/1.14.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/tocbot/4.1.1/tocbot.min.js"></script>
<script src="Skywalker.js"></script>
</body>
</html>